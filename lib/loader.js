// Generated by CoffeeScript 1.8.0
(function() {
  var async, detectFormat, extensions, fs, _;

  _ = require('underscore');

  fs = require('fs');

  fs.path = require('path');

  fs.findit = require('findit');

  async = require('async');

  exports.extensions = extensions = ['.yml', '.yaml', '.md', '.markdown', '.textile', '.adoc', '.asciidoc'];

  exports.detectFormat = detectFormat = function(path) {
    var extension, name;
    name = path.replace(/\.ya?ml/g, '');
    extension = fs.path.extname(name);
    switch (extension) {
      case '.md':
      case '.markdown':
        return 'markdown';
      case '.textile':
        return 'textile';
      case '.asciidoc':
      case '.adoc':
        return 'asciidoc';
      default:
        return void 0;
    }
  };

  exports.isNewer = function(input, output) {
    try {
      input = (fs.statSync(input)).mtime;
      output = (fs.statSync(output)).mtime;
      return input.getTime() > output.getTime();
    } catch (_error) {
      return true;
    }
  };

  exports.load = function(filenames, callback) {
    var directory, getContent, getContents, getPaths, isDirectory, root;
    isDirectory = (fs.statSync(filenames[0])).isDirectory();
    if (isDirectory) {
      directory = filenames[0];
      root = fs.path.resolve(directory);
      getPaths = function(done) {
        var finder, paths;
        paths = [];
        finder = fs.findit(directory);
        finder.on('file', function(file, stat) {
          var extension;
          extension = fs.path.extname(file);
          if (_.contains(extensions, extension)) {
            return paths.push(fs.path.resolve(file));
          }
        });
        return finder.on('end', function() {
          return done(null, paths);
        });
      };
    } else {
      root = process.cwd();
      getPaths = function(done) {
        var filename, paths;
        paths = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = filenames.length; _i < _len; _i++) {
            filename = filenames[_i];
            _results.push(fs.path.resolve(filename));
          }
          return _results;
        })();
        return process.nextTick(function() {
          return done(null, paths);
        });
      };
    }
    getContent = function(path, done) {
      var format;
      format = detectFormat(path);
      return fs.readFile(path, {
        encoding: 'utf8'
      }, function(err, content) {
        return done(err, {
          path: path,
          content: content,
          format: format
        });
      });
    };
    getContents = function(paths, done) {
      return async.map(paths, getContent, done);
    };
    return async.waterfall([getPaths, getContents], function(err, files) {
      return callback(err, files, root);
    });
  };

}).call(this);
